# View 和 CALayer 的内存优化

在iOS 6之后，`ViewController` 不再调用 `viewWillUnload` 或 `viewDidUnload`，这是因为 `ViewController` 不再自动卸载它们的视图。

我们的第一个想法可能是：那么如何手动卸载内存不足警告的视图呢？这似乎是一种倒退。

然后得到了这个答案：

```objective-c
- (void)didReceiveMemoryWarning {
    [super didReceiveMemoryWarning];
    if(self.isViewLoaded && !self.view.window)
        self.view = nil;
}
```

由于对 `UIView` 的底层支持进行了一些更改，这既不必要，也可能有害。因此在实际中，很少需要在内存不足警告时卸载 `ViewController` 的视图。从理论上讲，你永远不必这么做。

UIView 是 UIResponder的一个子类，并且有一个指向它自己的CALayer实例的指针。

CALayer 是位图图像的容器。当 UIView 运行 drawRect: 方法时，它正在为其层创建位图图像。层的其余实例变量（其中许多引用自其UIView，如frame和backgroundColor）指示如何以及在哪里将位图图像合成到屏幕上。

但层的最大部分（就内存使用而言）是位图。一个层本身只有48个字节，而标准UIView只有96个字节，而不管它们在屏幕上的大小。但是，根据层的边界，层位图的内存消耗会变得非常大。例如，一个全屏视网膜显示的iPad视图可以高达12兆字节。

ios6采用的方法是内存不足警告只会破坏层的位图，但保持CALayer和UIView对象的完整性。鉴于视图和层的内存消耗与位图相比相对较小，这是有意义的。另外，可以通过再次运行drawRect:来重新绘制位图，这样就不会丢失任何东西。

事实上，这种方法获得了一些好处：在内存不足警告之后，您的控制器不再需要重新填充视图内容。例如，考虑一个维护两个文本字段的视图控制器。如果视图控制器的视图将离开屏幕并出现内存不足警告，则视图控制器必须将当前文本保存在这些文本字段中，并在viewDidLoad或viewW中重新填充它们依拉佩尔：。这不再是一个问题，因为文本字段永远不会被破坏，因此当再次绘制文本字段的位图时，它们会保留文本。这简化了UIViewController代码中一个非常容易出错的部分。

有一些额外的智能内置在这个过程中倾倒层的位图图像，真的很酷。首先，让我们确保我们理解分配和释放。分配内存（对象、位图等）时，堆中大小适当的内存块被标记为“正在使用”，并返回指向该内存块开头的指针。在对象分配的情况下，我们将指针视为“对象”，但实际上，它只是“正在使用”内存块的地址。

当内存块被分配（“正在使用”）时，有一些保护程序阻止代码使用该内存，除非通过在分配期间返回的指针访问它。从某种意义上说，除非你打算破坏它，否则记忆是安全的。

释放只是删除这些保护，并将该内存块标记为“未使用”。这意味着下次分配对象时，可以使用部分或全部“未使用”内存来形成新的分配。释放后，存储在该内存块中的值不会更改。虽然有可能再次访问释放的内存，并且可能是相同的，但内存可能在某种程度上发生了变化。因此，从没有给你安全的内存分配指针。

现在，我们来看看为什么这对视图及其图层很重要。每个层都有一个contents属性，该属性指向表示该层位图的对象。这个对象的类型是一个名为CABackingStore的私有不透明类，它包含实际的位图和一些元数据（比如图像是否具有alpha通道以及每个像素使用了多少字节）。因此，当内存不足时，需要销毁的是CABackingStore。

然而，这里的妙招是内存不足警告不会破坏cabbackingstore。相反，如果视图在内存不足警告期间离开屏幕，则其层的CABackingStore设置为“volatile”。在这个上下文中，volatile标志（与C中的volatile关键字不同）类似于deallocation，因为它允许为不同的目的分配CABackingStore的内存。将此内存标记为volatile和释放它之间的区别在于，volatile内存实际上可以回收；它不会永远丢失。

考虑一下为什么这是一个如此有趣的优化。如果一个视图（更准确地说，它的层）要破坏它的后备存储，那么下次视图出现在屏幕上时，它必须通过运行drawRect:。

drawRect:是一个昂贵的电话，所以避免它是非常重要的。通过允许回收备份存储，该层可以避免其UIView再次执行drawRect:。

当然，有可能在备份存储被标记为volatile和拥有它的视图返回屏幕之间的某段时间内，该备份存储的内存被重新分配用于不同的目的。在这种情况下，视图必须再次运行其drawRect:方法来生成位图。